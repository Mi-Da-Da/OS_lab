# <center>Lab3</center>

## 练习1：完善中断处理 （需要编程）

&emsp;&emsp;如下是我们编程实现的时钟中断处理代码，我将在下面使用注释的形式解释。

```c
// Code/kern/trap/trap.c
case IRQ_S_TIMER:
            // "All bits besides SSIP and USIP in the sip register are
            // read-only." -- privileged spec1.9.1, 4.1.4, p59
            // In fact, Call sbi_set_timer will clear STIP, or you can clear it
            // directly.
            // cprintf("Supervisor timer interrupt\n");
             /* LAB3 EXERCISE1   2313815_段俊宇_2313485_陈展_2310591_李相儒  */
            /*(1)设置下次时钟中断- clock_set_next_event()
             *(2)计数器（ticks）加一
             *(3)当计数器加到100的时候，我们会输出一个`100ticks`表示我们触发了100次时钟中断，同时打印次数（num）加一
            * (4)判断打印次数，当打印次数为10时，调用<sbi.h>中的关机函数关机
            */
            ;
            int num = 0;	// 设置打印次数计数器
            while(1)		// 进入循环
            {
                clock_set_next_event();	// 设置下次时钟中断函数
                ticks++;				// 时钟中断次数加一
                if(ticks==TICK_NUM)		// TICK_NUM为宏定义的常量100，当时钟中断次数达到100的时候输出100ticks
                {
                    cprintf("100ticks\n");
                    ticks = 0;			// ticks计数器清零
                    num++;				// 打印次数计数器加一
                }
                if(num == 10)			// 当打印次数达到10次时，调用关机函数关机
                    sbi_shutdown();		// 关机函数，需要在最上面添加#include<sbi.h>进行声明
            }
            break;
```

&emsp;&emsp;使用$make{\quad}qemu$命令运行上面的代码，发现成功输出了10次100ticks，之后系统就停止了，说明关机成功

![](./Lab3实验报告_23113815_段俊宇_2313485_陈展_2310591_李相儒/1.png)

## 扩展练习 Challenge1：描述与理解中断流程

## 扩增练习 Challenge2：理解上下文切换机制

## 扩展练习Challenge3：完善异常中断

&emsp;&emsp;处理异常中断时，我们在$exception\_handler()$函数中编写输出信息的代码，我将使用注释来进行解释。

```c
// Code/kern/trap/trap.c
case CAUSE_ILLEGAL_INSTRUCTION:
             // 非法指令异常处理
             /* LAB3 CHALLENGE3   2313815_段俊宇_2313485_陈展_2310591_李相儒  */
            /*(1)输出指令异常类型（ Illegal instruction）
             *(2)输出异常指令地址
             *(3)更新 tf->epc寄存器
            */
			// 输出指令异常类型为非法指令
            cprintf("Exception type: Illegal instruction\n");			
			// 输出异常指令地址，ept是异常程序计数器，用于保存中断发生时正在执行的指令的地址，在处理完成后恢复执行
            cprintf("Illegal instruction caught at 0x%08x\n", tf->epc); 
			// 更新tf->epc寄存器，跳过非法指令，RISC-V中一条指令占4字节，因此需要加4
            tf->epc += 4;												
            break;
        case CAUSE_BREAKPOINT:
            //断点异常处理
            /* LAB3 CHALLLENGE3   2313815_段俊宇_2313485_陈展_2310591_李相儒  */
            /*(1)输出指令异常类型（ breakpoint）
             *(2)输出异常指令地址
             *(3)更新 tf->epc寄存器
            */
			// 输出指令异常类型为断点
            cprintf("Exception type: Breakpoint\n");
			// 输出异常指令地址
            cprintf("Breakpoint at 0x%08x\n", tf->epc);
			// 更新tf->epc寄存器，跳过断点
            tf->epc += 2;
            break;
```

&emsp;&emsp;还需要在$Code/kern/init/init.c$中$intr\_enable()$函数下面加入下面两行指令进行测试

```c
    asm("mret");
    asm("ebreak");
```

&emsp;&emsp;最后使用$make{\quad}qemu$命令运行结果如下所示，说明成功处理了非法指令和断点指令

![](./Lab3实验报告_23113815_段俊宇_2313485_陈展_2310591_李相儒/2.png)

## 遇到的问题

&emsp;&emsp;在处理断点指令的时候遇到了一个问题，通过查看$RV$硬件简要手册发现$ebreak$是$4$字节的指令，但是当$epc$加$4$的时候，按照$init.c$中的指令顺序，接下来应当什么都不做，进入死循环，然后输出时钟中断；然而输出结果如下所示，进入到了$default$分支，调用了$print\_trapframe()$函数，如下图所示，最终经过实验发现改为2的时候可以正确输出，但是不知道原因，届时需要询问助教。

![](./Lab3实验报告_23113815_段俊宇_2313485_陈展_2310591_李相儒/3.png)