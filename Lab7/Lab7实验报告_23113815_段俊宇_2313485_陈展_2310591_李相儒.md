# <center>Lab7</center>

## 练习1 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题（不需要编码）

&emsp;&emsp;

## 练习2 完成内核级条件变量和基于内核级条件变量的哲学家就餐问题（需要编码）

&emsp;&emsp;如下是$check_sync.c$文件中我们编写的哲学家就餐问题相关的代码，下面将使用注释的形式解释。

```c
void phi_take_forks_condvar(int i) {
     down(&(mtp->mutex));
//--------into routine in monitor--------------
    // LAB7 EXERCISE1: YOUR CODE
    // I am hungry
    // try to get fork
    // 设置自己为饥饿状态
    state_condvar[i] = HUNGRY;
    // 测试能否就餐
    phi_test_condvar(i);
    // 如果不能就餐，等待条件变量
    while(state_condvar[i] != EATING) {
        cond_wait(&mtp->cv[i]);
    }
//--------leave routine in monitor--------------
    // 离开管程
    if(mtp->next_count>0)
        up(&(mtp->next));
    else
        up(&(mtp->mutex));
}

void phi_put_forks_condvar(int i) {
     down(&(mtp->mutex));

//--------into routine in monitor--------------
    // LAB7 EXERCISE1: YOUR CODE
    // I ate over
    // test left and right neighbors
    // 设置自己为思考状态
    state_condvar[i] = THINKING;
    // 检查左右邻居是否能就餐
    phi_test_condvar(LEFT);
    phi_test_condvar(RIGHT);
//--------leave routine in monitor--------------
    // 离开管程
    if(mtp->next_count>0)
        up(&(mtp->next));
    else
        up(&(mtp->mutex));
}
```

&emsp;&emsp;经过上面的修改后，又对$monitor.c$中的内容进行了修改，下面将使用注释的形式解释。

```c
// Unlock one of threads waiting on the condition variable. 
void 
cond_signal (condvar_t *cvp) {
   //LAB7 EXERCISE1: YOUR CODE
   cprintf("cond_signal begin: cvp %x, cvp->count %d, cvp->owner->next_count %d\n", cvp, cvp->count, cvp->owner->next_count);  
  /*
   *      cond_signal(cv) {
   *          if(cv.count>0) {
   *             mt.next_count ++;
   *             signal(cv.sem);
   *             wait(mt.next);
   *             mt.next_count--;
   *          }
   *       }
   */
   // 如果有进程在等待
   if(cvp->count > 0) {
       // 增加next等待计数
       cvp->owner->next_count++;
       // 唤醒一个等待进程
       up(&(cvp->sem));
       // 自身在next上等待（让出管程）
       down(&(cvp->owner->next));
       // 被唤醒后减少计数
       cvp->owner->next_count--;
   }
   cprintf("cond_signal end: cvp %x, cvp->count %d, cvp->owner->next_count %d\n", cvp, cvp->count, cvp->owner->next_count);
}

// Suspend calling thread on a condition variable waiting for condition Atomically unlocks 
// mutex and suspends calling thread on conditional variable after waking up locks mutex. Notice: mp is mutex semaphore for monitor's procedures
void
cond_wait (condvar_t *cvp) {
    //LAB7 EXERCISE1: YOUR CODE
    cprintf("cond_wait begin:  cvp %x, cvp->count %d, cvp->owner->next_count %d\n", cvp, cvp->count, cvp->owner->next_count);
   /*
    *         cv.count ++;
    *         if(mt.next_count>0)
    *            signal(mt.next)
    *         else
    *            signal(mt.mutex);
    *         wait(cv.sem);
    *         cv.count --;
    */
    // 增加等待计数
    cvp->count++;
    // 如果有进程在next上等待
    if(cvp->owner->next_count > 0)
        // 唤醒其中一个
        up(&(cvp->owner->next));
    // 否则释放管程锁
    else
        up(&(cvp->owner->mutex));
    // 在条件变量上等待
    down(&(cvp->sem));
    // 被唤醒后减少计数
    cvp->count--;
    cprintf("cond_wait end:  cvp %x, cvp->count %d, cvp->owner->next_count %d\n", cvp, cvp->count, cvp->owner->next_count);
}
```

&emsp;&emsp;使用$make{\ }grade$命令可以得到满分，所有输出检测都显示$OK$，如下所示：

![](./Lab7实验报告_23113815_段俊宇_2313485_陈展_2310591_李相儒/1.png)

&emsp;&emsp;使用$make{\ }qemu$命令运行结果如下所示，输出了很多内容，包含五个哲学家就餐和思考的过程。

![](./Lab7实验报告_23113815_段俊宇_2313485_陈展_2310591_李相儒/2.png)

![](./Lab7实验报告_23113815_段俊宇_2313485_陈展_2310591_李相儒/3.png)

![](./Lab7实验报告_23113815_段俊宇_2313485_陈展_2310591_李相儒/4.png)

![](./Lab7实验报告_23113815_段俊宇_2313485_陈展_2310591_李相儒/5.png)

![](./Lab7实验报告_23113815_段俊宇_2313485_陈展_2310591_李相儒/6.png)

## 扩展练习 Challenge1：在ucore中实现简化的死锁和重入探测机制

## 扩展练习 Challenge2：参考Linux的RCU机制，在ucore中实现简化的RCU机制

