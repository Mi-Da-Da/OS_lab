# <center>Lab5</center>

## 练习0：填写已有实验

&emsp;&emsp;如下是初始化进程控制块的代码，在这里面新增了对等待时间和三个指针的初始化，下面将使用注释的形式解释。

```c
// alloc_proc - alloc a proc_struct and init all fields of proc_struct
static struct proc_struct *
alloc_proc(void)
{
    struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));
    if (proc != NULL)
    {
        // LAB4:EXERCISE1 2313815_段俊宇_2313485_陈展_2310591_李相儒
        /*
         * below fields in proc_struct need to be initialized
         *       enum proc_state state;                      // Process state
         *       int pid;                                    // Process ID
         *       int runs;                                   // the running times of Proces
         *       uintptr_t kstack;                           // Process kernel stack
         *       volatile bool need_resched;                 // bool value: need to be rescheduled to release CPU?
         *       struct proc_struct *parent;                 // the parent process
         *       struct mm_struct *mm;                       // Process's memory management field
         *       struct context context;                     // Switch here to run process
         *       struct trapframe *tf;                       // Trap frame for current interrupt
         *       uintptr_t pgdir;                            // the base addr of Page Directroy Table(PDT)
         *       uint32_t flags;                             // Process flag
         *       char name[PROC_NAME_LEN + 1];               // Process name
         */
        proc->state = PROC_UNINIT;                           // 进程状态初始化为未启动状态
        proc->pid = -1;                                      // 进程ID未分配，因此是-1
        proc->runs = 0;                                      // 进程运行次数初始化为0
        proc->kstack = 0;                                    // 内核栈指针初始化为0
        proc->need_resched = 0;                              // 是否需要重新调度设置为0，也就是不需要
        proc->parent = NULL;                                 // 父进程指针初始化为NULL
        proc->mm = NULL;                                     // 内存管理结构初始化为NULL
        memset(&(proc->context), 0, sizeof(struct context)); // 上下文结构体使用memset函数清零
        proc->tf = NULL;                                     // 中断帧指针初始化为NULL
        proc->pgdir = boot_pgdir_pa;                         // 页目录基址初始化为引导页目录物理地址
        proc->flags = 0;                                     // 进程标志清零
        memset(proc->name, 0, PROC_NAME_LEN+1);              // 进程名称清零
        list_init(&(proc->list_link));						 // 初始化进程链表
        list_init(&(proc->hash_link));						 // 初始化哈希链表
     
        // LAB5新增     
        proc->wait_state = 0;								 // 等待时间设置为0
        proc->cptr = NULL;									 // 指针初始化
        proc->optr = NULL;
        proc->yptr = NULL;
    }
    return proc;
}
```

&emsp;&emsp;如下是创建子进程函数的新增内容，下面将使用注释的形式解释

```c
int do_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf)
{
    int ret = -E_NO_FREE_PROC;
    struct proc_struct *proc;
    if (nr_process >= MAX_PROCESS)
    {
        goto fork_out;
    }
    ret = -E_NO_MEM;
    // LAB4:EXERCISE2 2313815_段俊宇_2313485_陈展_2310591_李相儒
    /*
     * Some Useful MACROs, Functions and DEFINEs, you can use them in below implementation.
     * MACROs or Functions:
     *   alloc_proc:   create a proc struct and init fields (lab4:exercise1)
     *   setup_kstack: alloc pages with size KSTACKPAGE as process kernel stack
     *   copy_mm:      process "proc" duplicate OR share process "current"'s mm according clone_flags
     *                 if clone_flags & CLONE_VM, then "share" ; else "duplicate"
     *   copy_thread:  setup the trapframe on the  process's kernel stack top and
     *                 setup the kernel entry point and stack of process
     *   hash_proc:    add proc into proc hash_list
     *   get_pid:      alloc a unique pid for process
     *   wakeup_proc:  set proc->state = PROC_RUNNABLE
     * VARIABLES:
     *   proc_list:    the process set's list
     *   nr_process:   the number of process set
     */

    //    1. call alloc_proc to allocate a proc_struct
    //    2. call setup_kstack to allocate a kernel stack for child process
    //    3. call copy_mm to dup OR share mm according clone_flag
    //    4. call copy_thread to setup tf & context in proc_struct
    //    5. insert proc_struct into hash_list && proc_list
    //    6. call wakeup_proc to make the new child process RUNNABLE
    //    7. set ret vaule using child proc's pid

    // LAB5 2313815_段俊宇_2313485_陈展_2310591_李相儒 : (update LAB4 steps)
    // TIPS: you should modify your written code in lab4(step1 and step5), not add more code.
    /* Some Functions
     *    set_links:  set the relation links of process.  ALSO SEE: remove_links:  lean the relation links of process
     *    -------------------
     *    update step 1: set child proc's parent to current process, make sure current process's wait_state is 0
     *    update step 5: insert proc_struct into hash_list && proc_list, set the relation links of process
     */
    // 1.调用alloc_proc，首先获得一块用户信息块
    proc = alloc_proc();
    if(proc==NULL)
        goto fork_out;
    // 2.使用setup_kstack()函数为进程分配一个内核栈
    if((setup_kstack(proc)!=0))
        goto bad_fork_cleanup_proc;
    // 3.使用copy_mm()函数复制原进程的内存管理信息到新进程
    if(copy_mm(clone_flags, proc)!=0)
        goto bad_fork_cleanup_kstack;
    // 4.使用copy_thread()函数复制原进程上下文到新进程
    copy_thread(proc, stack, tf);
	// 将现在进程设置为子进程的父进程并初始化等待时间
    proc->parent = current;
    assert(current->wait_state == 0);
    // 获取进程pid并添加到链表中，使用set_links函数
    proc->pid = get_pid();
    hash_proc(proc);
    set_links(proc);
	// 使用wakeup_proc()函数唤醒新进程，将进程状态设置为PROC_RUNNABLE
    wakeup_proc(proc);
	// 返回新进程号
    ret = proc->pid;

fork_out:
    return ret;

bad_fork_cleanup_kstack:
    put_kstack(proc);
bad_fork_cleanup_proc:
    kfree(proc);
    goto fork_out;
}
```

&emsp;&emsp;如下是$trap.c$中对时钟中断的设置，下面将使用注释的形式解释

```c
case IRQ_S_TIMER:
        // "All bits besides SSIP and USIP in the sip register are
        // read-only." -- privileged spec1.9.1, 4.1.4, p59
        // In fact, Call sbi_set_timer will clear STIP, or you can clear it
        // directly.
        // cprintf("Supervisor timer interrupt\n");
        /* LAB3 EXERCISE1   2313815_段俊宇_2313485_陈展_2310591_李相儒 :  */
        /*(1)设置下次时钟中断- clock_set_next_event()
         *(2)计数器（ticks）加一
         *(3)当计数器加到100的时候，我们会输出一个`100ticks`表示我们触发了100次时钟中断，同时打印次数（num）加一
         * (4)判断打印次数，当打印次数为10时，调用<sbi.h>中的关机函数关机
         */
		// 设置时钟中断
        clock_set_next_event();
		// 中断次数增加
        ticks++;
		// tick_num为100，打印次数加一
        if (ticks % TICK_NUM == 0) {
            print_ticks();
            // 当进程不为空时，状态设置为需要进行调度
            if(current != NULL)
            {
                current->need_resched = 1;
            }
        }
        break;
```

## 练习1 加载应用程序并执行（需要编码）

&emsp;&emsp;这是对$load\_icode$函数修改添加的部分，下面将使用注释解释

```c
//(6) setup trapframe for user environment
    struct trapframe *tf = current->tf;
    // Keep sstatus
    uintptr_t sstatus = tf->status;
    memset(tf, 0, sizeof(struct trapframe));
    /* LAB5:EXERCISE1 YOUR CODE
     * should set tf->gpr.sp, tf->epc, tf->status
     * NOTICE: If we set trapframe correctly, then the user level process can return to USER MODE from kernel. So
     *          tf->gpr.sp should be user stack top (the value of sp)
     *          tf->epc should be entry point of user program (the value of sepc)
     *          tf->status should be appropriate for user program (the value of sstatus)
     *          hint: check meaning of SPP, SPIE in SSTATUS, use them by SSTATUS_SPP, SSTATUS_SPIE(defined in risv.h)
     */
    // 设置用户栈指针
    tf->gpr.sp = (uintptr_t)USTACKTOP;

    // 设置程序入口指针
    tf->epc = (uintptr_t)elf->e_entry;

    // 设置用户态执行的返回值为0
    tf->gpr.a0 = 0;

    // 调整状态
    tf->status = (sstatus & ~SSTATUS_SPP) | SSTATUS_SPIE;
    
    ret = 0;
out:
    return ret;
bad_cleanup_mmap:
    exit_mmap(mm);
bad_elf_cleanup_pgdir:
    put_pgdir(mm);
bad_pgdir_cleanup_mm:
    mm_destroy(mm);
bad_mm:
    goto out;
```

&emsp;&emsp;**请简要描述这个用户态进程被$ucore$选择占用$CPU$执行（$RUNNING$态）到具体执行应用程序第一条指令的整个经过。**

1. 调度器选择一个就绪的用户进程并切换到它，使其进入 $RUNNING$态。
2.  $exec$ 加载 $ELF$，建立页表和用户 $vma$，为用户程序设置$trapframe$，包含程序入口和返回值。
3.  内核执行$sret$，将$CPU$从内核态切换到用户态，并恢复用户上下文。
4.  $CPU $跳到$EPC$，执行用户程序的第一条指令。

## 练习2 父进程复制自己的内存空间给子进程（需要编码）

&emsp;&emsp;如下是我们编写的$copy\_range()$函数，下面将使用注释的形式解释。

```c
/* copy_range - copy content of memory (start, end) of one process A to another
 * process B
 * @to:    the addr of process B's Page Directory
 * @from:  the addr of process A's Page Directory
 * @share: flags to indicate to dup OR share. We just use dup method, so it
 * didn't be used.
 *
 * CALL GRAPH: copy_mm-->dup_mmap-->copy_range
 */
int copy_range(pde_t *to, pde_t *from, uintptr_t start, uintptr_t end,
               bool share)
{
    assert(start % PGSIZE == 0 && end % PGSIZE == 0);
    assert(USER_ACCESS(start, end));
    // copy content by page unit.
    do
    {
        // call get_pte to find process A's pte according to the addr start
        pte_t *ptep = get_pte(from, start, 0), *nptep;
        if (ptep == NULL)
        {
            start = ROUNDDOWN(start + PTSIZE, PTSIZE);
            continue;
        }
        // call get_pte to find process B's pte according to the addr start. If
        // pte is NULL, just alloc a PT
        if (*ptep & PTE_V)
        {
            if ((nptep = get_pte(to, start, 1)) == NULL)
            {
                return -E_NO_MEM;
            }
            uint32_t perm = (*ptep & PTE_USER);
            // get page from ptep
            struct Page *page = pte2page(*ptep);
            // alloc a page for process B
            struct Page *npage = alloc_page();
            assert(page != NULL);
            assert(npage != NULL);
            /* LAB5:EXERCISE2 2313815_段俊宇_2313485_陈展_2310591_李相儒
             * replicate content of page to npage, build the map of phy addr of
             * nage with the linear addr start
             *
             * Some Useful MACROs and DEFINEs, you can use them in below
             * implementation.
             * MACROs or Functions:
             *    page2kva(struct Page *page): return the kernel vritual addr of
             * memory which page managed (SEE pmm.h)
             *    page_insert: build the map of phy addr of an Page with the
             * linear addr la
             *    memcpy: typical memory copy function
             *
             * (1) find src_kvaddr: the kernel virtual address of page
             * (2) find dst_kvaddr: the kernel virtual address of npage
             * (3) memory copy from src_kvaddr to dst_kvaddr, size is PGSIZE
             * (4) build the map of phy addr of  nage with the linear addr start
             */
            // 将源页和目标页转换成内核虚拟地址空间中的地址
            void *src_kvaddr = page2kva(page);
            void *dst_kvaddr = page2kva(npage);
            // 把整个旧页内容复制到新页
            memcpy(dst_kvaddr, src_kvaddr, PGSIZE);
            // 把新页映射到目标页表的虚拟地址上
            int ret = page_insert(to, npage, start, perm);
            assert(ret == 0);
        }
        start += PGSIZE;
    } while (start != 0 && start < end);
    return 0;
}
```

&emsp;&emsp;经过上面的修改后，依然不能得到$130$分，在讨论并询问大模型后，发现$trap.c$的内容需要进行修改，下面将使用注释的形式解释。

```c
// 处理页错误
static int
pgfault_handler(struct trapframe *tf) {
    // 取出错误地址
    uintptr_t addr = tf->tval;
    // 内核初始化阶段或进程切换尚未建立时发生错误
    if (current == NULL) {
        print_trapframe(tf);
        panic("page fault in kernel!");
    }
    // 内核线程运行时发生错误
    if (current->mm == NULL) {
        print_trapframe(tf);
        panic("page fault in kernel thread!");
    }

    return -E_INVAL;
}

// 具体错误处理
void exception_handler(struct trapframe *tf)
{
    int ret;
    switch (tf->cause)
    {
    case CAUSE_MISALIGNED_FETCH:
        cprintf("Instruction address misaligned\n");
        break;
    case CAUSE_FETCH_ACCESS:
        cprintf("Instruction access fault\n");
        break;
    case CAUSE_ILLEGAL_INSTRUCTION:
        cprintf("Illegal instruction\n");
        break;
    case CAUSE_BREAKPOINT:
        cprintf("Breakpoint\n");
        if (tf->gpr.a7 == 10)
        {
            tf->epc += 4;
            syscall();
            kernel_execve_ret(tf, current->kstack + KSTACKSIZE);
        }
        break;
    case CAUSE_MISALIGNED_LOAD:
        cprintf("Load address misaligned\n");
        break;
    case CAUSE_LOAD_ACCESS:
        cprintf("Load access fault\n");
        break;
    case CAUSE_MISALIGNED_STORE:
        panic("AMO address misaligned\n");
        break;
    case CAUSE_STORE_ACCESS:
        cprintf("Store/AMO access fault\n");
        break;
    case CAUSE_USER_ECALL:
        // cprintf("Environment call from U-mode\n");
        tf->epc += 4;
        syscall();
        break;
    case CAUSE_SUPERVISOR_ECALL:
        cprintf("Environment call from S-mode\n");
        tf->epc += 4;
        syscall();
        break;
    case CAUSE_HYPERVISOR_ECALL:
        cprintf("Environment call from H-mode\n");
        break;
    case CAUSE_MACHINE_ECALL:
        cprintf("Environment call from M-mode\n");
        break;
    // 指令取值异常，后面与这个的逻辑基本相同，只是输出不一致
    case CAUSE_FETCH_PAGE_FAULT:
        // 是否处理成功
        if ((ret = pgfault_handler(tf)) != 0) {
            // 打印错误信息
            cprintf("Fetch page fault\n");
            print_trapframe(tf);
            // 用户态进程造成的错误，直接结束进程
            if (current != NULL) {
                do_exit(-E_KILLED);
            } else {
                panic("kernel page fault");
            }
        }
        break;
    // 数据加载异常
    case CAUSE_LOAD_PAGE_FAULT:
        if ((ret = pgfault_handler(tf)) != 0) {
            cprintf("Load page fault\n");
            print_trapframe(tf);
            if (current != NULL) {
                do_exit(-E_KILLED);
            } else {
                panic("kernel page fault");
            }
        }
        break;
    // 数据存储异常
    case CAUSE_STORE_PAGE_FAULT:
        if ((ret = pgfault_handler(tf)) != 0) {
            cprintf("Store/AMO page fault\n");
            print_trapframe(tf);
            if (current != NULL) {
                do_exit(-E_KILLED);
            } else {
                panic("kernel page fault");
            }
        }
        break;
    default:
        print_trapframe(tf);
        break;
    }
}
```

&emsp;&emsp;经过上面的改动，在使用$make{\ }grade$命令时终于可以得到满分$130$，通过了全部的测试点，如下所示：

![](./Lab5实验报告_23113815_段俊宇_2313485_陈展_2310591_李相儒/1.png)

## 练习3：阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现（不需要编码）

&emsp;&emsp;

## 分支任务：gdb 调试系统调用以及返回

&emsp;&emsp;**在大模型的帮助下，完成整个调试的流程，观察一下ecall指令和sret指令是如何被qemu处理的，并简单阅读一下调试中涉及到的qemu源码，解释其中的关键流程。**

&emsp;&emsp;首先，整个调试流程的编辑内容由我这里提供材料，大模型整理并提供初版，最后由我来进行微调得到。

&emsp;&emsp;其次，对下一问中$TCG Translation$部分关键函数文件$translate.c$的代码阅读，大模型提供了一定帮助。

&emsp;&emsp;现在，我们给出对$ecall$指令和$sret$指令调试的流程与具体分析：

- **1、找到 ecall 指令**

&emsp;&emsp;根据指导书上的指令，我们打断点并前进至断点处后，查看后续 10 条指令，发现 $ecall$ 位置

![](./Lab5实验报告_23113815_段俊宇_2313485_陈展_2310591_李相儒/101.png)

&emsp;&emsp;我们新创一个断点，使当前指令直接行进至 $ecall$ 处：$break~*0x800104$

- **2、设置 ecall 处断点**

&emsp;&emsp;首先打断 $qemu$ 的执行，接着如下设置断点：

```
break riscv_cpu_do_interrupt
c
```

- **3、观察异常处理**

&emsp;&emsp;我们向下执行指令，触发断点，结果如下所示：

![](./Lab5实验报告_23113815_段俊宇_2313485_陈展_2310591_李相儒/102.png)

```
[Switching to Thread 0x7fb655f9d6c0 (LWP 1475)]

Thread 2 "qemu-system-ris" hit Breakpoint 1, riscv_cpu_do_interrupt (cs=0x561b64a63800)
    at /mnt/c/Users/admin/Desktop/学校/作业/第五学期作业/操作系统作业/Lab/插件/qemu-4.1.1/target/riscv/cpu_helper.c:507
507         RISCVCPU *cpu = RISCV_CPU(cs);
(gdb) bt
#0  riscv_cpu_do_interrupt (cs=0x561b64a63800)
    at /mnt/c/Users/admin/Desktop/学校/作业/第五学期作业/操作系统作业/Lab/插件/qemu-4.1.1/target/riscv/cpu_helper.c:507
#1  0x0000561b4e05245d in cpu_handle_exception (cpu=0x561b64a63800, ret=0x7fb655f9c97c)
    at /mnt/c/Users/admin/Desktop/学校/作业/第五学期作业/操作系统作业/Lab/插件/qemu-4.1.1/accel/tcg/cpu-exec.c:506
#2  0x0000561b4e052ae9 in cpu_exec (cpu=0x561b64a63800)
    at /mnt/c/Users/admin/Desktop/学校/作业/第五学期作业/操作系统作业/Lab/插件/qemu-4.1.1/accel/tcg/cpu-exec.c:712
#3  0x0000561b4e004cdf in tcg_cpu_exec (cpu=0x561b64a63800)
    at /mnt/c/Users/admin/Desktop/学校/作业/第五学期作业/操作系统作业/Lab/插件/qemu-4.1.1/cpus.c:1435
#4  0x0000561b4e005598 in qemu_tcg_cpu_thread_fn (arg=0x561b64a63800)
    at /mnt/c/Users/admin/Desktop/学校/作业/第五学期作业/操作系统作业/Lab/插件/qemu-4.1.1/cpus.c:1743
#5  0x0000561b4e488728 in qemu_thread_start (args=0x561b64a79e90) at util/qemu-thread-posix.c:502
#6  0x00007fb656958aa4 in start_thread (arg=<optimized out>) at ./nptl/pthread_create.c:447
#7  0x00007fb6569e5c6c in clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:78
```

&emsp;&emsp;从代码可知，为抵达异常处理函数，也即是我们设置的断点，从 $qemu$ 线程启动函数开始，经过 $TCG~CPU$ 执行循环

- **4、找到 sret 指令**

&emsp;&emsp;根据此前的实验内容，在执行完 SAVE_ALL 后，还会执行 RESTORE_ALL，在此之后即执行 sret 指令。我们使用 $x/100i~\$pc$ 指令大范围搜索，找到 $sret$ 指令，并效仿前面的操作，设置断点并行进至 $sret$ 前 ：

![](./Lab5实验报告_23113815_段俊宇_2313485_陈展_2310591_李相儒/103.png)

- **5、根据源码分析流程**

&emsp;&emsp;我们在 $qemu$ 项目的 $riscv$ 目录中遍历寻找 $sret$ 字段，以寻找处理 $sret$ 指令的函数并进行分析：

![](./Lab5实验报告_23113815_段俊宇_2313485_陈展_2310591_李相儒/104.png)

&emsp;&emsp;我们得到了三个用于处理 $sret$ 的函数，我们对其进行分析：

```C
static bool trans_sret(DisasContext *ctx, arg_sret *a)
{
#ifndef CONFIG_USER_ONLY  // 只有在系统模式下才支持
    // 1. 将下一条指令地址保存到 cpu_pc
    tcg_gen_movi_tl(cpu_pc, ctx->base.pc_next);
    
    // 2. 检查是否支持 Supervisor 扩展（RVS）
    if (has_ext(ctx, RVS)) {
        // 3. 生成对 helper_sret 的调用
        gen_helper_sret(cpu_pc, cpu_env, cpu_pc);
        
        // 4. 设置翻译块退出标志
        exit_tb(ctx);  /* no chaining */
        ctx->base.is_jmp = DISAS_NORETURN;  // 不会返回到当前翻译块
        
        return true;
    } else {
        return false;  // 不支持 RVS 扩展
    }
#else
    return false;  // 用户模式下不支持
#endif
}

target_ulong helper_sret(CPURISCVState *env, target_ulong cpu_pc_deb)
{
    // 1. 权限检查：当前权限必须至少是 Supervisor
    if (!(env->priv >= PRV_S)) {
        riscv_raise_exception(env, RISCV_EXCP_ILLEGAL_INST, GETPC());
    }

    // 2. 获取返回地址（sepc - Supervisor Exception PC）
    target_ulong retpc = env->sepc;
    
    // 3. 对齐检查（如果没有 C 扩展，地址必须是 4 字节对齐）
    if (!riscv_has_ext(env, RVC) && (retpc & 0x3)) {
        riscv_raise_exception(env, RISCV_EXCP_INST_ADDR_MIS, GETPC());
    }

    // 4. TSR（Trap SRET）检查（特权版本 ≥ 1.10）
    if (env->priv_ver >= PRIV_VERSION_1_10_0 &&
        get_field(env->mstatus, MSTATUS_TSR)) {
        riscv_raise_exception(env, RISCV_EXCP_ILLEGAL_INST, GETPC());
    }

    // 5. 恢复 mstatus 寄存器状态
    target_ulong mstatus = env->mstatus;
    target_ulong prev_priv = get_field(mstatus, MSTATUS_SPP);  // 获取之前的权限级别
    
    // 恢复中断使能位
    mstatus = set_field(mstatus,
        env->priv_ver >= PRIV_VERSION_1_10_0 ?
        MSTATUS_SIE : MSTATUS_UIE << prev_priv,  // 根据特权版本选择正确的位
        get_field(mstatus, MSTATUS_SPIE));  // 将 SPIE 恢复到 SIE/UIE
    
    mstatus = set_field(mstatus, MSTATUS_SPIE, 0);  // 清除 SPIE
    mstatus = set_field(mstatus, MSTATUS_SPP, PRV_U);  // 设置 SPP 为用户模式
    
    // 6. 设置 CPU 模式和 mstatus
    riscv_cpu_set_mode(env, prev_priv);  // 切换到之前的权限级别
    env->mstatus = mstatus;
    
    // 7. 返回要跳转的地址
    return retpc;
}
```

&emsp;&emsp;**在执行ecall和sret这类汇编指令的时候，qemu进行了很关键的一步——指令翻译（TCG Translation），了解一下这个功能，思考一下另一个双重gdb调试的实验是否也涉及到了一些相关的内容。**

&emsp;&emsp;结论：有涉及到，在$ucore$执行访存指令时，就会调用$TCG$翻译访存指令，这里询问大模型得到函数位置位于$translate.c$。

&emsp;&emsp;我们现在来分析这个文件所涉及到的函数，这一部分完全由大模型处理：

```c
#include "qemu/osdep.h"
#include "qemu/log.h"
#include "cpu.h"
#include "tcg-op.h"
#include "disas/disas.h"
#include "exec/cpu_ldst.h"
#include "exec/exec-all.h"
#include "exec/helper-proto.h"
#include "exec/helper-gen.h"
#include "exec/translator.h"
#include "exec/log.h"
#include "instmap.h"

static TCGv cpu_gpr[32], cpu_pc;
static TCGv_i64 cpu_fpr[32];
static TCGv load_res;
static TCGv load_val;
#include "exec/gen-icount.h"

typedef struct DisasContext {
    DisasContextBase base;
    target_ulong pc_succ_insn;
    target_ulong priv_ver;
    uint32_t opcode;
    uint32_t mstatus_fs;
    uint32_t misa;
    uint32_t mem_idx;
    int frm;
    bool ext_ifencei;
} DisasContext;

#ifdef TARGET_RISCV64
static const int tcg_memop_lookup[8] = {
    [0 ... 7] = -1,
    [0] = MO_SB,
    [1] = MO_TESW,
    [2] = MO_TESL,
    [4] = MO_UB,
    [5] = MO_TEUW,
#ifdef TARGET_RISCV64
    [3] = MO_TEQ,
    [6] = MO_TEUL,
#endif
};
#endif

#ifdef TARGET_RISCV64
#define CASE_OP_32_64(X) case X: case glue(X, W)
#else
#define CASE_OP_32_64(X) case X
#endif

static inline bool has_ext(DisasContext *ctx, uint32_t ext)  // 检查CPU是否支持某个扩展
{
    return ctx->misa & ext;
}

static void generate_exception(DisasContext *ctx, int excp)  // 生成异常处理代码
{
    tcg_gen_movi_tl(cpu_pc, ctx->base.pc_next);
    TCGv_i32 helper_tmp = tcg_const_i32(excp);
    gen_helper_raise_exception(cpu_env, helper_tmp);
    tcg_temp_free_i32(helper_tmp);
    ctx->base.is_jmp = DISAS_NORETURN;
}

static void generate_exception_mbadaddr(DisasContext *ctx, int excp)  // 生成带错误地址的异常
{
    tcg_gen_movi_tl(cpu_pc, ctx->base.pc_next);
    tcg_gen_st_tl(cpu_pc, cpu_env, offsetof(CPURISCVState, badaddr));
    TCGv_i32 helper_tmp = tcg_const_i32(excp);
    gen_helper_raise_exception(cpu_env, helper_tmp);
    tcg_temp_free_i32(helper_tmp);
    ctx->base.is_jmp = DISAS_NORETURN;
}

static void gen_exception_debug(void)  // 生成调试异常
{
    TCGv_i32 helper_tmp = tcg_const_i32(EXCP_DEBUG);
    gen_helper_raise_exception(cpu_env, helper_tmp);
    tcg_temp_free_i32(helper_tmp);
}

static void exit_tb(DisasContext *ctx)  // 退出翻译块，处理单步执行
{
    if (ctx->base.singlestep_enabled) {
        gen_exception_debug();
    } else {
        tcg_gen_exit_tb(NULL, 0);
    }
}

static void lookup_and_goto_ptr(DisasContext *ctx)  // 查找并跳转到翻译块
{
    if (ctx->base.singlestep_enabled) {
        gen_exception_debug();
    } else {
        tcg_gen_lookup_and_goto_ptr();
    }
}

static void gen_exception_illegal(DisasContext *ctx)  // 生成非法指令异常
{
    generate_exception(ctx, RISCV_EXCP_ILLEGAL_INST);
}

static void gen_exception_inst_addr_mis(DisasContext *ctx)  // 生成指令地址不对齐异常
{
    generate_exception_mbadaddr(ctx, RISCV_EXCP_INST_ADDR_MIS);
}

static inline bool use_goto_tb(DisasContext *ctx, target_ulong dest)  // 判断是否可以使用直接跳转
{
    if (unlikely(ctx->base.singlestep_enabled)) {
        return false;
    }
#ifndef CONFIG_USER_ONLY
    return (ctx->base.tb->pc & TARGET_PAGE_MASK) == (dest & TARGET_PAGE_MASK);
#else
    return true;
#endif
}

static void gen_goto_tb(DisasContext *ctx, int n, target_ulong dest)  // 生成翻译块跳转代码
{
    if (use_goto_tb(ctx, dest)) {
        tcg_gen_goto_tb(n);
        tcg_gen_movi_tl(cpu_pc, dest);
        tcg_gen_exit_tb(ctx->base.tb, n);
    } else {
        tcg_gen_movi_tl(cpu_pc, dest);
        lookup_and_goto_ptr(ctx);
    }
}

static inline void gen_get_gpr(TCGv t, int reg_num)  // 读取通用寄存器值
{
    if (reg_num == 0) {
        tcg_gen_movi_tl(t, 0);
    } else {
        tcg_gen_mov_tl(t, cpu_gpr[reg_num]);
    }
}

static inline void gen_set_gpr(int reg_num_dst, TCGv t)  // 写入通用寄存器值
{
    if (reg_num_dst != 0) {
        tcg_gen_mov_tl(cpu_gpr[reg_num_dst], t);
    }
}

static void gen_mulhsu(TCGv ret, TCGv arg1, TCGv arg2)  // 生成有符号×无符号乘法高位结果
{
    TCGv rl = tcg_temp_new();
    TCGv rh = tcg_temp_new();
    tcg_gen_mulu2_tl(rl, rh, arg1, arg2);
    tcg_gen_sari_tl(rl, arg1, TARGET_LONG_BITS - 1);
    tcg_gen_and_tl(rl, rl, arg2);
    tcg_gen_sub_tl(ret, rh, rl);
    tcg_temp_free(rl);
    tcg_temp_free(rh);
}

static void gen_div(TCGv ret, TCGv source1, TCGv source2)  // 生成有符号除法代码
{
    TCGv cond1, cond2, zeroreg, resultopt1;
    cond1 = tcg_temp_new();
    cond2 = tcg_temp_new();
    zeroreg = tcg_const_tl(0);
    resultopt1 = tcg_temp_new();
    tcg_gen_movi_tl(resultopt1, (target_ulong)-1);
    tcg_gen_setcondi_tl(TCG_COND_EQ, cond2, source2, (target_ulong)(~0L));
    tcg_gen_setcondi_tl(TCG_COND_EQ, cond1, source1,
                        ((target_ulong)1) << (TARGET_LONG_BITS - 1));
    tcg_gen_and_tl(cond1, cond1, cond2);
    tcg_gen_setcondi_tl(TCG_COND_EQ, cond2, source2, 0);
    tcg_gen_movcond_tl(TCG_COND_EQ, source1, cond2, zeroreg, source1,
            resultopt1);
    tcg_gen_or_tl(cond1, cond1, cond2);
    tcg_gen_movi_tl(resultopt1, (target_ulong)1);
    tcg_gen_movcond_tl(TCG_COND_EQ, source2, cond1, zeroreg, source2,
            resultopt1);
    tcg_gen_div_tl(ret, source1, source2);
    tcg_temp_free(cond1);
    tcg_temp_free(cond2);
    tcg_temp_free(zeroreg);
    tcg_temp_free(resultopt1);
}

static void gen_divu(TCGv ret, TCGv source1, TCGv source2)  // 生成无符号除法代码
{
    TCGv cond1, zeroreg, resultopt1;
    cond1 = tcg_temp_new();
    zeroreg = tcg_const_tl(0);
    resultopt1 = tcg_temp_new();
    tcg_gen_setcondi_tl(TCG_COND_EQ, cond1, source2, 0);
    tcg_gen_movi_tl(resultopt1, (target_ulong)-1);
    tcg_gen_movcond_tl(TCG_COND_EQ, source1, cond1, zeroreg, source1,
            resultopt1);
    tcg_gen_movi_tl(resultopt1, (target_ulong)1);
    tcg_gen_movcond_tl(TCG_COND_EQ, source2, cond1, zeroreg, source2,
            resultopt1);
    tcg_gen_divu_tl(ret, source1, source2);
    tcg_temp_free(cond1);
    tcg_temp_free(zeroreg);
    tcg_temp_free(resultopt1);
}

static void gen_rem(TCGv ret, TCGv source1, TCGv source2)  // 生成有符号取余代码
{
    TCGv cond1, cond2, zeroreg, resultopt1;
    cond1 = tcg_temp_new();
    cond2 = tcg_temp_new();
    zeroreg = tcg_const_tl(0);
    resultopt1 = tcg_temp_new();
    tcg_gen_movi_tl(resultopt1, 1L);
    tcg_gen_setcondi_tl(TCG_COND_EQ, cond2, source2, (target_ulong)-1);
    tcg_gen_setcondi_tl(TCG_COND_EQ, cond1, source1,
                        (target_ulong)1 << (TARGET_LONG_BITS - 1));
    tcg_gen_and_tl(cond2, cond1, cond2);
    tcg_gen_setcondi_tl(TCG_COND_EQ, cond1, source2, 0);
    tcg_gen_or_tl(cond2, cond1, cond2);
    tcg_gen_movcond_tl(TCG_COND_EQ, source2, cond2, zeroreg, source2,
            resultopt1);
    tcg_gen_rem_tl(resultopt1, source1, source2);
    tcg_gen_movcond_tl(TCG_COND_EQ, ret, cond1, zeroreg, resultopt1,
            source1);
    tcg_temp_free(cond1);
    tcg_temp_free(cond2);
    tcg_temp_free(zeroreg);
    tcg_temp_free(resultopt1);
}

static void gen_remu(TCGv ret, TCGv source1, TCGv source2)  // 生成无符号取余代码
{
    TCGv cond1, zeroreg, resultopt1;
    cond1 = tcg_temp_new();
    zeroreg = tcg_const_tl(0);
    resultopt1 = tcg_temp_new();
    tcg_gen_movi_tl(resultopt1, (target_ulong)1);
    tcg_gen_setcondi_tl(TCG_COND_EQ, cond1, source2, 0);
    tcg_gen_movcond_tl(TCG_COND_EQ, source2, cond1, zeroreg, source2,
            resultopt1);
    tcg_gen_remu_tl(resultopt1, source1, source2);
    tcg_gen_movcond_tl(TCG_COND_EQ, ret, cond1, zeroreg, resultopt1,
            source1);
    tcg_temp_free(cond1);
    tcg_temp_free(zeroreg);
    tcg_temp_free(resultopt1);
}

static void gen_jal(DisasContext *ctx, int rd, target_ulong imm)  // 生成JAL指令代码
{
    target_ulong next_pc;
    next_pc = ctx->base.pc_next + imm;
    if (!has_ext(ctx, RVC)) {
        if ((next_pc & 0x3) != 0) {
            gen_exception_inst_addr_mis(ctx);
            return;
        }
    }
    if (rd != 0) {
        tcg_gen_movi_tl(cpu_gpr[rd], ctx->pc_succ_insn);
    }
    gen_goto_tb(ctx, 0, ctx->base.pc_next + imm);
    ctx->base.is_jmp = DISAS_NORETURN;
}

#ifdef TARGET_RISCV64
static void gen_load_c(DisasContext *ctx, uint32_t opc, int rd, int rs1,
        target_long imm)  // 生成压缩加载指令代码
{
    TCGv t0 = tcg_temp_new();
    TCGv t1 = tcg_temp_new();
    gen_get_gpr(t0, rs1);
    tcg_gen_addi_tl(t0, t0, imm);
    int memop = tcg_memop_lookup[(opc >> 12) & 0x7];
    if (memop < 0) {
        gen_exception_illegal(ctx);
        return;
    }
    tcg_gen_qemu_ld_tl(t1, t0, ctx->mem_idx, memop);
    gen_set_gpr(rd, t1);
    tcg_temp_free(t0);
    tcg_temp_free(t1);
}

static void gen_store_c(DisasContext *ctx, uint32_t opc, int rs1, int rs2,
        target_long imm)  // 生成压缩存储指令代码
{
    TCGv t0 = tcg_temp_new();
    TCGv dat = tcg_temp_new();
    gen_get_gpr(t0, rs1);
    tcg_gen_addi_tl(t0, t0, imm);
    gen_get_gpr(dat, rs2);
    int memop = tcg_memop_lookup[(opc >> 12) & 0x7];
    if (memop < 0) {
        gen_exception_illegal(ctx);
        return;
    }
    tcg_gen_qemu_st_tl(dat, t0, ctx->mem_idx, memop);
    tcg_temp_free(t0);
    tcg_temp_free(dat);
}
#endif

#ifndef CONFIG_USER_ONLY
static void mark_fs_dirty(DisasContext *ctx)  // 标记浮点状态为脏
{
    TCGv tmp;
    if (ctx->mstatus_fs == MSTATUS_FS) {
        return;
    }
    ctx->mstatus_fs = MSTATUS_FS;
    tmp = tcg_temp_new();
    tcg_gen_ld_tl(tmp, cpu_env, offsetof(CPURISCVState, mstatus));
    tcg_gen_ori_tl(tmp, tmp, MSTATUS_FS);
    tcg_gen_st_tl(tmp, cpu_env, offsetof(CPURISCVState, mstatus));
    tcg_temp_free(tmp);
}
#else
static inline void mark_fs_dirty(DisasContext *ctx) { }
#endif

#if !defined(TARGET_RISCV64)
static void gen_fp_load(DisasContext *ctx, uint32_t opc, int rd,
        int rs1, target_long imm)  // 生成浮点加载指令代码
{
    TCGv t0;
    if (ctx->mstatus_fs == 0) {
        gen_exception_illegal(ctx);
        return;
    }
    t0 = tcg_temp_new();
    gen_get_gpr(t0, rs1);
    tcg_gen_addi_tl(t0, t0, imm);
    switch (opc) {
    case OPC_RISC_FLW:
        if (!has_ext(ctx, RVF)) {
            goto do_illegal;
        }
        tcg_gen_qemu_ld_i64(cpu_fpr[rd], t0, ctx->mem_idx, MO_TEUL);
        tcg_gen_ori_i64(cpu_fpr[rd], cpu_fpr[rd], 0xffffffff00000000ULL);
        break;
    case OPC_RISC_FLD:
        if (!has_ext(ctx, RVD)) {
            goto do_illegal;
        }
        tcg_gen_qemu_ld_i64(cpu_fpr[rd], t0, ctx->mem_idx, MO_TEQ);
        break;
    do_illegal:
    default:
        gen_exception_illegal(ctx);
        break;
    }
    tcg_temp_free(t0);
    mark_fs_dirty(ctx);
}

static void gen_fp_store(DisasContext *ctx, uint32_t opc, int rs1,
        int rs2, target_long imm)  // 生成浮点存储指令代码
{
    TCGv t0;
    if (ctx->mstatus_fs == 0) {
        gen_exception_illegal(ctx);
        return;
    }
    t0 = tcg_temp_new();
    gen_get_gpr(t0, rs1);
    tcg_gen_addi_tl(t0, t0, imm);
    switch (opc) {
    case OPC_RISC_FSW:
        if (!has_ext(ctx, RVF)) {
            goto do_illegal;
        }
        tcg_gen_qemu_st_i64(cpu_fpr[rs2], t0, ctx->mem_idx, MO_TEUL);
        break;
    case OPC_RISC_FSD:
        if (!has_ext(ctx, RVD)) {
            goto do_illegal;
        }
        tcg_gen_qemu_st_i64(cpu_fpr[rs2], t0, ctx->mem_idx, MO_TEQ);
        break;
    do_illegal:
    default:
        gen_exception_illegal(ctx);
        break;
    }
    tcg_temp_free(t0);
}
#endif

static void gen_set_rm(DisasContext *ctx, int rm)  // 设置浮点舍入模式
{
    TCGv_i32 t0;
    if (ctx->frm == rm) {
        return;
    }
    ctx->frm = rm;
    t0 = tcg_const_i32(rm);
    gen_helper_set_rounding_mode(cpu_env, t0);
    tcg_temp_free_i32(t0);
}

static void decode_RV32_64C0(DisasContext *ctx)  // 解码RV32/64压缩指令第0组
{
    uint8_t funct3 = extract32(ctx->opcode, 13, 3);
    uint8_t rd_rs2 = GET_C_RS2S(ctx->opcode);
    uint8_t rs1s = GET_C_RS1S(ctx->opcode);
    switch (funct3) {
    case 3:
#if defined(TARGET_RISCV64)
        gen_load_c(ctx, OPC_RISC_LD, rd_rs2, rs1s,
                 GET_C_LD_IMM(ctx->opcode));
#else
        gen_fp_load(ctx, OPC_RISC_FLW, rd_rs2, rs1s,
                    GET_C_LW_IMM(ctx->opcode));
#endif
        break;
    case 7:
#if defined(TARGET_RISCV64)
        gen_store_c(ctx, OPC_RISC_SD, rs1s, rd_rs2,
                  GET_C_LD_IMM(ctx->opcode));
#else
        gen_fp_store(ctx, OPC_RISC_FSW, rs1s, rd_rs2,
                     GET_C_LW_IMM(ctx->opcode));
#endif
        break;
    }
}

static void decode_RV32_64C(DisasContext *ctx)  // 解码RV32/64压缩指令
{
    uint8_t op = extract32(ctx->opcode, 0, 2);
    switch (op) {
    case 0:
        decode_RV32_64C0(ctx);
        break;
    }
}

#define EX_SH(amount) \
    static int ex_shift_##amount(DisasContext *ctx, int imm) \
    {                                         \
        return imm << amount;                 \
    }
EX_SH(1)
EX_SH(2)
EX_SH(3)
EX_SH(4)
EX_SH(12)

#define REQUIRE_EXT(ctx, ext) do { \
    if (!has_ext(ctx, ext)) {      \
        return false;              \
    }                              \
} while (0)

static int ex_rvc_register(DisasContext *ctx, int reg)  // 扩展压缩指令寄存器编号
{
    return 8 + reg;
}

static int ex_rvc_shifti(DisasContext *ctx, int imm)  // 扩展压缩移位立即数
{
    return imm ? imm : 64;
}

#include "decode_insn32.inc.c"

static bool gen_arith_imm_fn(DisasContext *ctx, arg_i *a,
                             void (*func)(TCGv, TCGv, target_long))  // 生成立即数算术运算
{
    TCGv source1;
    source1 = tcg_temp_new();
    gen_get_gpr(source1, a->rs1);
    (*func)(source1, source1, a->imm);
    gen_set_gpr(a->rd, source1);
    tcg_temp_free(source1);
    return true;
}

static bool gen_arith_imm_tl(DisasContext *ctx, arg_i *a,
                             void (*func)(TCGv, TCGv, TCGv))  // 生成立即数算术运算（TCGv版本）
{
    TCGv source1, source2;
    source1 = tcg_temp_new();
    source2 = tcg_temp_new();
    gen_get_gpr(source1, a->rs1);
    tcg_gen_movi_tl(source2, a->imm);
    (*func)(source1, source1, source2);
    gen_set_gpr(a->rd, source1);
    tcg_temp_free(source1);
    tcg_temp_free(source2);
    return true;
}

#ifdef TARGET_RISCV64
static void gen_addw(TCGv ret, TCGv arg1, TCGv arg2)  // 生成32位加法代码
{
    tcg_gen_add_tl(ret, arg1, arg2);
    tcg_gen_ext32s_tl(ret, ret);
}

static void gen_subw(TCGv ret, TCGv arg1, TCGv arg2)  // 生成32位减法代码
{
    tcg_gen_sub_tl(ret, arg1, arg2);
    tcg_gen_ext32s_tl(ret, ret);
}

static void gen_mulw(TCGv ret, TCGv arg1, TCGv arg2)  // 生成32位乘法代码
{
    tcg_gen_mul_tl(ret, arg1, arg2);
    tcg_gen_ext32s_tl(ret, ret);
}

static bool gen_arith_div_w(DisasContext *ctx, arg_r *a,
                            void(*func)(TCGv, TCGv, TCGv))  // 生成32位有符号除法运算
{
    TCGv source1, source2;
    source1 = tcg_temp_new();
    source2 = tcg_temp_new();
    gen_get_gpr(source1, a->rs1);
    gen_get_gpr(source2, a->rs2);
    tcg_gen_ext32s_tl(source1, source1);
    tcg_gen_ext32s_tl(source2, source2);
    (*func)(source1, source1, source2);
    tcg_gen_ext32s_tl(source1, source1);
    gen_set_gpr(a->rd, source1);
    tcg_temp_free(source1);
    tcg_temp_free(source2);
    return true;
}

static bool gen_arith_div_uw(DisasContext *ctx, arg_r *a,
                            void(*func)(TCGv, TCGv, TCGv))  // 生成32位无符号除法运算
{
    TCGv source1, source2;
    source1 = tcg_temp_new();
    source2 = tcg_temp_new();
    gen_get_gpr(source1, a->rs1);
    gen_get_gpr(source2, a->rs2);
    tcg_gen_ext32u_tl(source1, source1);
    tcg_gen_ext32u_tl(source2, source2);
    (*func)(source1, source1, source2);
    tcg_gen_ext32s_tl(source1, source1);
    gen_set_gpr(a->rd, source1);
    tcg_temp_free(source1);
    tcg_temp_free(source2);
    return true;
}

#endif

static bool gen_arith(DisasContext *ctx, arg_r *a,
                      void(*func)(TCGv, TCGv, TCGv))  // 生成寄存器算术运算
{
    TCGv source1, source2;
    source1 = tcg_temp_new();
    source2 = tcg_temp_new();
    gen_get_gpr(source1, a->rs1);
    gen_get_gpr(source2, a->rs2);
    (*func)(source1, source1, source2);
    gen_set_gpr(a->rd, source1);
    tcg_temp_free(source1);
    tcg_temp_free(source2);
    return true;
}

static bool gen_shift(DisasContext *ctx, arg_r *a,
                        void(*func)(TCGv, TCGv, TCGv))  // 生成移位运算
{
    TCGv source1 = tcg_temp_new();
    TCGv source2 = tcg_temp_new();
    gen_get_gpr(source1, a->rs1);
    gen_get_gpr(source2, a->rs2);
    tcg_gen_andi_tl(source2, source2, TARGET_LONG_BITS - 1);
    (*func)(source1, source1, source2);
    gen_set_gpr(a->rd, source1);
    tcg_temp_free(source1);
    tcg_temp_free(source2);
    return true;
}

#include "insn_trans/trans_rvi.inc.c"
#include "insn_trans/trans_rvm.inc.c"
#include "insn_trans/trans_rva.inc.c"
#include "insn_trans/trans_rvf.inc.c"
#include "insn_trans/trans_rvd.inc.c"
#include "insn_trans/trans_privileged.inc.c"

#ifdef CONFIG_PRAGMA_DIAGNOSTIC_AVAILABLE
# pragma GCC diagnostic push
# pragma GCC diagnostic ignored "-Wredundant-decls"
# ifdef __clang__
#  pragma GCC diagnostic ignored "-Wtypedef-redefinition"
# endif
#endif

#include "decode_insn16.inc.c"

#ifdef CONFIG_PRAGMA_DIAGNOSTIC_AVAILABLE
# pragma GCC diagnostic pop
#endif

static void decode_opc(DisasContext *ctx)  // 解码操作码主函数
{
    if (extract32(ctx->opcode, 0, 2) != 3) {
        if (!has_ext(ctx, RVC)) {
            gen_exception_illegal(ctx);
        } else {
            ctx->pc_succ_insn = ctx->base.pc_next + 2;
            if (!decode_insn16(ctx, ctx->opcode)) {
                decode_RV32_64C(ctx);
            }
        }
    } else {
        ctx->pc_succ_insn = ctx->base.pc_next + 4;
        if (!decode_insn32(ctx, ctx->opcode)) {
            gen_exception_illegal(ctx);
        }
    }
}

static void riscv_tr_init_disas_context(DisasContextBase *dcbase, CPUState *cs)  // 初始化反汇编上下文
{
    DisasContext *ctx = container_of(dcbase, DisasContext, base);
    CPURISCVState *env = cs->env_ptr;
    RISCVCPU *cpu = RISCV_CPU(cs);
    ctx->pc_succ_insn = ctx->base.pc_first;
    ctx->mem_idx = ctx->base.tb->flags & TB_FLAGS_MMU_MASK;
    ctx->mstatus_fs = ctx->base.tb->flags & TB_FLAGS_MSTATUS_FS;
    ctx->priv_ver = env->priv_ver;
    ctx->misa = env->misa;
    ctx->frm = -1;
    ctx->ext_ifencei = cpu->cfg.ext_ifencei;
}

static void riscv_tr_tb_start(DisasContextBase *db, CPUState *cpu)  // 翻译块开始回调
{
}

static void riscv_tr_insn_start(DisasContextBase *dcbase, CPUState *cpu)  // 指令开始回调
{
    DisasContext *ctx = container_of(dcbase, DisasContext, base);
    tcg_gen_insn_start(ctx->base.pc_next);
}

static bool riscv_tr_breakpoint_check(DisasContextBase *dcbase, CPUState *cpu,
                                      const CPUBreakpoint *bp)  // 断点检查回调
{
    DisasContext *ctx = container_of(dcbase, DisasContext, base);
    tcg_gen_movi_tl(cpu_pc, ctx->base.pc_next);
    ctx->base.is_jmp = DISAS_NORETURN;
    gen_exception_debug();
    ctx->base.pc_next += 4;
    return true;
}

static void riscv_tr_translate_insn(DisasContextBase *dcbase, CPUState *cpu)  // 翻译单条指令
{
    DisasContext *ctx = container_of(dcbase, DisasContext, base);
    CPURISCVState *env = cpu->env_ptr;
    ctx->opcode = cpu_ldl_code(env, ctx->base.pc_next);
    decode_opc(ctx);
    ctx->base.pc_next = ctx->pc_succ_insn;
    if (ctx->base.is_jmp == DISAS_NEXT) {
        target_ulong page_start;
        page_start = ctx->base.pc_first & TARGET_PAGE_MASK;
        if (ctx->base.pc_next - page_start >= TARGET_PAGE_SIZE) {
            ctx->base.is_jmp = DISAS_TOO_MANY;
        }
    }
}

static void riscv_tr_tb_stop(DisasContextBase *dcbase, CPUState *cpu)  // 翻译块结束回调
{
    DisasContext *ctx = container_of(dcbase, DisasContext, base);
    switch (ctx->base.is_jmp) {
    case DISAS_TOO_MANY:
        gen_goto_tb(ctx, 0, ctx->base.pc_next);
        break;
    case DISAS_NORETURN:
        break;
    default:
        g_assert_not_reached();
    }
}

static void riscv_tr_disas_log(const DisasContextBase *dcbase, CPUState *cpu)  // 反汇编日志回调
{
    qemu_log("IN: %s\n", lookup_symbol(dcbase->pc_first));
    log_target_disas(cpu, dcbase->pc_first, dcbase->tb->size);
}

static const TranslatorOps riscv_tr_ops = {
    .init_disas_context = riscv_tr_init_disas_context,
    .tb_start           = riscv_tr_tb_start,
    .insn_start         = riscv_tr_insn_start,
    .breakpoint_check   = riscv_tr_breakpoint_check,
    .translate_insn     = riscv_tr_translate_insn,
    .tb_stop            = riscv_tr_tb_stop,
    .disas_log          = riscv_tr_disas_log,
};

void gen_intermediate_code(CPUState *cs, TranslationBlock *tb, int max_insns)  // 生成中间代码主入口
{
    DisasContext ctx;
    translator_loop(&riscv_tr_ops, &ctx.base, cs, tb, max_insns);
}

void riscv_translate_init(void)  // RISC-V翻译器初始化
{
    int i;
    cpu_gpr[0] = NULL;
    for (i = 1; i < 32; i++) {
        cpu_gpr[i] = tcg_global_mem_new(cpu_env,
            offsetof(CPURISCVState, gpr[i]), riscv_int_regnames[i]);
    }
    for (i = 0; i < 32; i++) {
        cpu_fpr[i] = tcg_global_mem_new_i64(cpu_env,
            offsetof(CPURISCVState, fpr[i]), riscv_fpr_regnames[i]);
    }
    cpu_pc = tcg_global_mem_new(cpu_env, offsetof(CPURISCVState, pc), "pc");
    load_res = tcg_global_mem_new(cpu_env, offsetof(CPURISCVState, load_res),
                             "load_res");
    load_val = tcg_global_mem_new(cpu_env, offsetof(CPURISCVState, load_val),
                             "load_val");
}
```

&emsp;&emsp;根据上述分析，我们总结 TCG 翻译流程如下：

1. **初始化阶段**：
   - `riscv_translate_init()`：初始化TCG全局变量，注册CPU寄存器和状态变量
   - 为每个通用寄存器（gpr）、浮点寄存器（fpr）、程序计数器（pc）等创建TCG全局变量
2. **翻译块（TB）翻译**：
   - 调用`gen_intermediate_code()`开始翻译一个基本块
   - 通过`translator_loop()`进入主翻译循环
   - 设置`TranslatorOps`回调函数结构体
3. **翻译循环的各个阶段**：
   a. `riscv_tr_init_disas_context()`：初始化反汇编上下文
   b. `riscv_tr_tb_start()`：翻译块开始
   c. 循环翻译每条指令：
   - `riscv_tr_insn_start()`：记录指令边界
   - `riscv_tr_breakpoint_check()`：检查断点
   - `riscv_tr_translate_insn()`：核心翻译函数

&emsp;&emsp;**记录下你调试过程中比较有趣的细节，以及在观察模拟器通过软件模拟硬件执行的时候了解到的知识**。

&emsp;&emsp;实验中发现，结构体 $env$ 中没有 $sstatus$ 属性，只有 $mstatus$。

## 分支任务：gdb 调试页表查询过程

#### &emsp;&emsp;调用路径及关键函数

&emsp;&emsp;调用的关键路径如下：

```
1. ucore访存指令执行
2. QEMU TCG翻译访存指令
3. 调用访存指令的helper函数
4. 检查虚拟地址空间
4.1  检查 TLB 缓存（快路径）
     ↓
4.2 TLB 未命中 → 进入页表遍历（慢路径）
     ↓
4.3  读取 satp 寄存器获取页表基址
5. Sv39 模式遍历三级页表
6. 返回物理地址
```

&emsp;&emsp;调用过程中使用的关键函数如下：

```
target/riscv/cpu_helper.c  get_physical_address
// 以下是伪代码展示，由大模型总结
函数：获取物理地址
输入：
    env: CPU状态
    physical: 指向物理地址的指针
    prot: 指向页面保护位的指针
    addr: 虚拟地址
    access_type: 访问类型（取指/读/写）
    mmu_idx: MMU索引
输出：
    转换结果（成功/失败/PMP失败）

步骤：
1.  确定访问模式：
    mode = mmu_idx
    if mode == 机器模式 且 access_type != 取指:
        if MPRV位被设置:
            mode = MPP字段的值

2.  检查是否需要地址转换：
    if mode == 机器模式 或 CPU不支持MMU:
        physical = addr
        prot = 可读|可写|可执行
        返回 转换成功

3.  初始化：
    prot = 0
    根据权限版本选择地址转换模式：
    if 版本 >= 1.10:
        base = satp.PPN << 页大小偏移
        sum = mstatus.SUM位
        vm = satp.MODE字段
        case vm of:
            SV32: levels=2, ptidxbits=10, ptesize=4
            SV39: levels=3, ptidxbits=9, ptesize=8
            SV48: levels=4, ptidxbits=9, ptesize=8
            SV57: levels=5, ptidxbits=9, ptesize=8
            MBARE: 
                physical = addr
                prot = 可读|可写|可执行
                返回 转换成功
    else: (版本 < 1.10)
        base = sptbr << 页大小偏移
        sum = !mstatus.PUM位
        vm = mstatus.VM字段
        case vm of:
            SV32: levels=2, ptidxbits=10, ptesize=4
            SV39: levels=3, ptidxbits=9, ptesize=8
            SV48: levels=4, ptidxbits=9, ptesize=8
            MBARE: 
                physical = addr
                prot = 可读|可写|可执行
                返回 转换成功

4.  虚拟地址符号扩展检查：
    va_bits = 页大小偏移 + levels * ptidxbits
    mask = (1 << (长整型位数 - (va_bits - 1))) - 1
    masked_msbs = (addr >> (va_bits - 1)) & mask
    if masked_msbs != 0 且 masked_msbs != mask:
        返回 转换失败

5.  页表遍历：
    ptshift = (levels - 1) * ptidxbits
    
    遍历每一级页表 (i = 0 到 levels-1):
        idx = (addr >> (页大小偏移 + ptshift)) & ((1 << ptidxbits) - 1)
        pte_addr = base + idx * ptesize
        
        # 检查PTE物理地址访问权限
        if 支持PMP 且 没有访问权限:
            返回 PMP失败
        
        # 读取PTE
        pte = 从物理地址pte_addr读取
        
        ppn = pte >> PPN偏移
        
        # PTE有效性检查
        if PTE无效:
            返回 转换失败
        else if 是中间PTE (没有R/W/X位):
            base = ppn << 页大小偏移
            continue
        else if 保留的叶子PTE标志:
            返回 转换失败
        else if 权限检查失败:
            返回 转换失败
        else if PPN不对齐:
            返回 转换失败
        else if 访问权限检查失败:
            返回 转换失败
        else:
            # 叶子PTE找到，更新访问/脏位
            updated_pte = pte | 访问位
            if access_type == 数据存储:
                updated_pte |= 脏位
            
            if updated_pte != pte:
                # 原子更新PTE
                if PTE在RAM中:
                    if TCG_OVERSIZED_GUEST:
                        *pte_pa = updated_pte
                    else:
                        old_pte = 原子比较交换(pte_pa, pte, updated_pte)
                        if old_pte != pte:
                            重新开始页表遍历
                else:
                    返回 转换失败
            
            # 计算物理地址
            vpn = addr >> 页大小偏移
            physical = (ppn | (vpn & ((1 << ptshift) - 1))) << 页大小偏移
            
            # 设置保护位
            if PTE可读 或 (PTE可执行 且 MXR位设置):
                prot |= 可读
            if PTE可执行:
                prot |= 可执行
            if PTE可写 且 (access_type == 数据存储 或 PTE脏位已设置):
                prot |= 可写
            
            返回 转换成功
        
        ptshift -= ptidxbits  # 准备下一级

6.  如果循环结束仍未返回，则：
    返回 转换失败
    
target/riscv/cpu_helper.c  riscv_cpu_tlb_fill
函数：RISC-V CPU TLB填充
输入：
    cs: CPU状态
    address: 虚拟地址
    size: 访问大小
    access_type: 访问类型（取指/读/写）
    mmu_idx: MMU索引
    probe: 探测模式标志（仅检查，不实际填充）
    retaddr: 返回地址（用于异常处理）
输出：
    bool: TLB填充是否成功

步骤：
1.  #ifndef CONFIG_USER_ONLY（仅在全系统模拟模式下执行）
    （用户模式模拟有独立处理路径）

2.  初始化：
    cpu = RISCV_CPU(cs)
    env = cpu->env
    pa = 0（物理地址）
    prot = 0（页面保护位）
    pmp_violation = false（PMP违规标志）
    ret = 转换失败（初始状态）
    mode = mmu_idx

3.  记录调试信息：
    输出"函数名 地址 访问类型 mmu_idx"

4.  获取物理地址和权限：
    ret = get_physical_address(env, &pa, &prot, address, access_type, mmu_idx)

5.  确定实际访问模式（用于PMP检查）：
    if mode == 机器模式 且 access_type != 取指:
        if MPRV位被设置:
            mode = MPP字段的值

6.  记录转换结果调试信息：
    输出"函数名 地址 返回值 物理地址 保护位"

7.  PMP（物理内存保护）检查：
    if 支持PMP特性 且 ret == 转换成功:
        if !pmp_hart_has_privs(env, pa, size, 1 << access_type, mode):
            ret = PMP失败
    
    if ret == PMP失败:
        pmp_violation = true（标记为PMP违规）

8.  处理转换结果：
    case 转换成功:
        # 设置TLB页表项
        tlb_set_page(cs, 
                     address & 页面掩码,        # 虚拟页地址
                     pa & 页面掩码,            # 物理页地址
                     prot,                     # 页面保护位
                     mmu_idx,                  # MMU索引
                     页面大小)                  # 标准页面大小
        return true（TLB填充成功）

    case 其他结果（转换失败/PMP失败）:
        if probe模式:
            return false（仅探测，不触发异常）
        else:
            # 触发异常
            raise_mmu_exception(env, address, access_type, pmp_violation)
            设置异常索引到cs->exception_index
            riscv_raise_exception(env, cs->exception_index, retaddr)
            # 函数在此处不会返回，控制流跳转到异常处理程序

9.  #else（用户模式模拟路径）
    根据访问类型设置异常索引：
        case 取指: cs->exception_index = 指令页错误
        case 读: cs->exception_index = 加载页错误  
        case 写: cs->exception_index = 存储页错误
    
    cpu_loop_exit_restore(cs, retaddr)  # 退出并恢复执行环境
    # 函数在此处不会返回
```

#### &emsp;&emsp;单步调试页表翻译流程

#### &emsp;&emsp;QEMU模拟TLB同真实CPU TLB区别

&emsp;&emsp;最大的区别是 $qemu$ 直接使用虚拟地址作为物理地址，也就是将 SATP 寄存器的值记为0，以下是 AI 总结的区别：

| 特性     | QEMU模拟的TLB                    | 真实CPU的TLB                   |
| :------- | :------------------------------- | :----------------------------- |
| 实现方式 | 由软件程序实现                   | 通过专用硬件电路实现           |
| 存储位置 | 存放在内存的数据结构中           | 位于CPU内部的SRAM存储单元      |
| 查询速度 | 较慢，需经过程序指令执行         | 极快，通常只需一到两个时钟周期 |
| 容量     | 一般较大且可调整配置             | 容量较小，大多为几十到上千项   |
| 一致性   | 依赖软件管理，可能存在一致性问题 | 由硬件自动保证，始终保持一致   |
| 调试能力 | 支持断点、单步跟踪等软件调试手段 | 无法进行直接调试               |
